---
title: Custom Notification Channels
description: Implementing custom notification channels to extend Glueful's notification system
navigation:
  icon: i-lucide-bell-plus
---

# Custom Notification Channels

This guide explains how to extend the Glueful notification system by creating custom notification channels. Custom channels allow you to deliver notifications through additional services like SMS, push notifications, Slack, or any other delivery method.

## Understanding Notification Channels

In Glueful, notification channels are responsible for delivering notifications through specific services or protocols. The framework includes built-in support for database notifications and email notifications (via extensions), but you can add your own channels to support additional delivery methods.

## Creating a Custom Notification Channel

A notification channel must implement the `NotificationChannel` interface, which defines the contract for all notification channels in the system.

### Step 1: Create Your Channel Class

Create a new class that implements the `Glueful\Notifications\Contracts\NotificationChannel` interface:

```php
<?php
declare(strict_types=1);

namespace YourNamespace;

use Glueful\Notifications\Contracts\Notifiable;
use Glueful\Notifications\Contracts\NotificationChannel;

class SlackNotificationChannel implements NotificationChannel
{
    /**
     * @var array Configuration options for the Slack channel
     */
    private array $config;

    /**
     * SlackNotificationChannel constructor
     *
     * @param array $config Configuration options
     */
    public function __construct(array $config = [])
    {
        $this->config = $config;
    }

    /**
     * Get the channel name.
     *
     * @return string The name of the notification channel
     */
    public function getChannelName(): string
    {
        return 'slack';
    }

    /**
     * Send the notification to the specified notifiable entity.
     *
     * @param Notifiable $notifiable The entity receiving the notification
     * @param array $data Notification data including content and metadata
     * @return bool Whether the notification was sent successfully
     */
    public function send(Notifiable $notifiable, array $data): bool
    {
        // Get the Slack webhook URL
        $webhookUrl = $notifiable->routeNotificationFor('slack') ?? $this->config['webhook_url'] ?? null;

        if (!$webhookUrl) {
            return false;
        }

        // Format the data for Slack
        $payload = $this->formatPayload($data);

        // Send to Slack using webhook
        return $this->sendToWebhook($webhookUrl, $payload);
    }

    /**
     * Format the notification data for this channel.
     *
     * @param array $data The raw notification data
     * @param Notifiable $notifiable The entity receiving the notification
     * @return array The formatted data for this channel
     */
    public function format(array $data, Notifiable $notifiable): array
    {
        // Format the notification data for Slack
        return [
            'text' => $data['subject'] ?? 'New notification',
            'blocks' => [
                [
                    'type' => 'section',
                    'text' => [
                        'type' => 'mrkdwn',
                        'text' => $data['message'] ?? $data['subject'] ?? 'No content'
                    ]
                ]
            ],
            'attachments' => $this->formatAttachments($data)
        ];
    }

    /**
     * Check if the channel is available.
     *
     * @return bool Whether the channel is available for use
     */
    public function isAvailable(): bool
    {
        // Check if the Slack integration is properly configured
        return isset($this->config['webhook_url']) || isset($this->config['api_token']);
    }

    /**
     * Format attachments for Slack
     *
     * @param array $data Notification data
     * @return array Formatted attachments
     */
    private function formatAttachments(array $data): array
    {
        $attachments = [];

        // Add notification details as attachment if available
        if (isset($data['details']) && is_array($data['details'])) {
            $fields = [];

            foreach ($data['details'] as $key => $value) {
                $fields[] = [
                    'type' => 'mrkdwn',
                    'text' => "*{$key}*: {$value}"
                ];
            }

            $attachments[] = [
                'color' => $data['color'] ?? '#3490dc',
                'fields' => $fields
            ];
        }

        return $attachments;
    }

    /**
     * Send payload to Slack webhook
     *
     * @param string $webhookUrl Slack webhook URL
     * @param array $payload Data to send
     * @return bool Success status
     */
    private function sendToWebhook(string $webhookUrl, array $payload): bool
    {
        $ch = curl_init($webhookUrl);
        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'POST');
        curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($payload));
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_HTTPHEADER, [
            'Content-Type: application/json',
            'Content-Length: ' . strlen(json_encode($payload))
        ]);

        $result = curl_exec($ch);
        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        curl_close($ch);

        return $httpCode >= 200 && $httpCode < 300;
    }
}
```

### Step 2: Register Your Channel

Once you've created your channel class, you need to register it with the `ChannelManager`. The simplest way to do this is through an extension:

```php
<?php
declare(strict_types=1);

namespace YourNamespace;

use Glueful\Notifications\Contracts\NotificationExtension;
use Glueful\Notifications\Contracts\Notifiable;

class SlackNotificationExtension implements NotificationExtension
{
    /**
     * @var SlackNotificationChannel The Slack channel instance
     */
    private SlackNotificationChannel $channel;

    /**
     * @var array Configuration options
     */
    private array $config = [];

    /**
     * Get the extension name.
     *
     * @return string The name of the notification extension
     */
    public function getExtensionName(): string
    {
        return 'slack_notification';
    }

    /**
     * Initialize the extension.
     *
     * @param array $config Configuration options for the extension
     * @return bool Whether the initialization was successful
     */
    public function initialize(array $config = []): bool
    {
        $this->config = $config;
        $this->channel = new SlackNotificationChannel($config);
        return true;
    }

    /**
     * Get the supported notification types.
     *
     * @return array List of notification types supported by this extension
     */
    public function getSupportedNotificationTypes(): array
    {
        // This extension can handle all notification types
        return ['*'];
    }

    /**
     * Process the notification before it's sent.
     *
     * @param array $data The notification data
     * @param Notifiable $notifiable The entity receiving the notification
     * @param string $channel The notification channel
     * @param string $type The notification type
     * @return array The processed notification data
     */
    public function processBeforeSend(array $data, Notifiable $notifiable, string $channel, string $type): array
    {
        // Only process for our specific channel
        if ($channel !== 'slack') {
            return $data;
        }

        // Add custom processing if needed
        return $data;
    }

    /**
     * Process the notification after it's sent.
     *
     * @param array $data The notification data
     * @param Notifiable $notifiable The entity receiving the notification
     * @param string $channel The notification channel
     * @param bool $success Whether the notification was sent successfully
     * @param string $type The notification type
     * @return void
     */
    public function processAfterSend(array $data, Notifiable $notifiable, string $channel, bool $success, string $type): void
    {
        // Handle post-sending logic if needed
    }

    /**
     * Get the notification channel provided by this extension.
     *
     * @return SlackNotificationChannel The Slack notification channel
     */
    public function getChannel(): SlackNotificationChannel
    {
        return $this->channel;
    }
}
```

### Step 3: Register Your Extension

Create a provider class to register your extension with the system:

```php
<?php
declare(strict_types=1);

namespace YourNamespace;

use Glueful\Helpers\ExtensionManager;

class SlackNotificationProvider
{
    public function register(ExtensionManager $extensionManager)
    {
        // Create the extension
        $extension = new SlackNotificationExtension();

        // Initialize it with configuration
        $extension->initialize([
            'webhook_url' => env('SLACK_WEBHOOK_URL'),
            'api_token' => env('SLACK_API_TOKEN'),
            'default_channel' => env('SLACK_DEFAULT_CHANNEL', '#notifications')
        ]);

        // Register the extension with the notification dispatcher
        $notificationDispatcher = $extensionManager->getNotificationDispatcher();
        $notificationDispatcher->registerExtension($extension);

        // Register the channel with the channel manager
        $channelManager = $notificationDispatcher->getChannelManager();
        $channelManager->registerChannel($extension->getChannel());
    }
}
```

### Step 4: Configure Your Extension

Add your extension configuration to `config/extensions.php`:

```php
return [
    // Other extensions...
    'slack_notification' => [
        'provider' => \YourNamespace\SlackNotificationProvider::class,
        'enabled' => true,
        'config' => [
            'webhook_url' => env('SLACK_WEBHOOK_URL'),
            'api_token' => env('SLACK_API_TOKEN'),
            'default_channel' => env('SLACK_DEFAULT_CHANNEL', '#notifications'),
        ],
    ],
];
```

## Supporting Notification Routing

To make your channel work seamlessly with the routing system, ensure that notifiable entities can provide appropriate routing information:

```php
class User implements \Glueful\Notifications\Contracts\Notifiable
{
    // ... other Notifiable methods ...

    public function routeNotificationFor(string $channel)
    {
        if ($channel === 'slack') {
            return $this->slack_webhook_url ?? $this->slack_user_id ?? null;
        }

        // Handle other channels
        return parent::routeNotificationFor($channel);
    }
}
```

## Handling Notification Templates

For more complex formatting needs, you can implement template support for your channel:

```php
class SlackTemplateFormatter
{
    private array $templates = [];

    public function __construct()
    {
        // Register default templates
        $this->templates = [
            'default' => [
                'color' => '#3490dc',
                'template' => '*{{subject}}*\n{{message}}'
            ],
            'alert' => [
                'color' => '#e3342f',
                'template' => '<!channel> *ALERT: {{subject}}*\n{{message}}'
            ],
            'success' => [
                'color' => '#38c172',
                'template' => '*{{subject}}*\n:white_check_mark: {{message}}'
            ]
        ];
    }

    public function format(string $template, array $data): array
    {
        // Get template or use default
        $templateConfig = $this->templates[$template] ?? $this->templates['default'];

        // Replace placeholders
        $text = $templateConfig['template'];
        foreach ($data as $key => $value) {
            if (is_string($value)) {
                $text = str_replace('{{' . $key . '}}', $value, $text);
            }
        }

        return [
            'text' => $text,
            'color' => $templateConfig['color']
        ];
    }

    public function registerTemplate(string $name, array $template)
    {
        $this->templates[$name] = $template;
    }
}
```

## Event Listeners

You can also implement event listeners to handle specific notification events for your channel:

```php
class SlackNotificationListener implements \Glueful\Events\EventListener
{
    public function getSubscribedEvents(): array
    {
        return [
            'notification.sent',
            'notification.failed'
        ];
    }

    public function handle(object $event)
    {
        // Only process events for the slack channel
        if ($event->getChannel() !== 'slack') {
            return;
        }

        if ($event instanceof \Glueful\Notifications\Events\NotificationSent) {
            $this->handleSentEvent($event);
        } elseif ($event instanceof \Glueful\Notifications\Events\NotificationFailed) {
            $this->handleFailedEvent($event);
        }
    }

    // Handler implementations...
}
```

## Testing Your Channel

Create tests to ensure your channel works correctly:

```php
// Test sending a notification through your channel
$user = new User();
$notificationService = new NotificationService(/* ... */);

$result = $notificationService->send(
    'test_notification',
    $user,
    'Test Notification',
    ['message' => 'This is a test notification'],
    ['channels' => ['slack']]
);

// Check the result
assert($result['status'] === 'success');
```

## Best Practices

1. **Error Handling**: Always implement robust error handling in your channel's `send()` method.
2. **Configuration**: Make your channel configurable through environment variables.
3. **Throttling**: Implement rate limiting to avoid API rate limits with external services.
4. **Fallbacks**: Consider providing fallback mechanisms when primary delivery fails.
5. **Logging**: Log sending attempts and results for debugging purposes.
