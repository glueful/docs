---
title: Notification System
description: Working with Glueful's notification system
navigation:
  icon: i-lucide-bell
---

# Notification System

Glueful provides a robust, multi-channel notification system for sending notifications to your users through various delivery methods.

## Overview

The notification system lets you send messages to users through multiple channels including:

- In-app notifications (stored in database)
- Email notifications (via the Email Notification extension)
- Custom notification channels (via extensions)

## Core Components

### Notification Service

The central service that manages the entire notification lifecycle:

```php
// Sending a notification
$notificationService->send(
    'account_verification',    // notification type
    $user,                     // notifiable entity
    'Verify Your Account',     // subject
    [                          // additional data
        'verification_url' => $url,
        'expiry_minutes' => 30
    ],
    [                          // options
        'channels' => ['email', 'database'],
        'priority' => 'high'
    ]
);

// Retrieving notifications
$notifications = $notificationService->getNotifications($user, true); // true = only unread

// Mark as read
$notificationService->markAsRead($notification);
```

### NotificationDispatcher

Handles sending notifications through appropriate channels and manages notification events:

```php
// The dispatcher is usually used internally by the NotificationService
$dispatcher = new NotificationDispatcher($channelManager);
$result = $dispatcher->send($notification, $notifiable, ['email', 'database']);
```

### ChannelManager

Registers and manages notification channels:

```php
$channelManager = new ChannelManager();
$channelManager->registerChannel(new EmailChannel());
$channelManager->registerChannel(new DatabaseChannel());
```

## Notification Events

The system triggers events during the notification lifecycle:

- `NotificationSent`: When a notification is successfully sent
- `NotificationFailed`: When notification delivery fails
- `NotificationRead`: When a user reads a notification
- `NotificationScheduled`: When a notification is scheduled for future delivery

## Creating Notifiable Entities

Any entity that can receive notifications must implement the `Notifiable` interface:

```php
class User implements \Glueful\Notifications\Contracts\Notifiable
{
    private string $uuid;
    private string $email;

    public function routeNotificationFor(string $channel)
    {
        if ($channel === 'email') {
            return $this->email;
        }
        return null;
    }

    public function getNotifiableId(): string
    {
        return $this->uuid;
    }

    public function getNotifiableType(): string
    {
        return 'user';
    }

    public function shouldReceiveNotification(string $notificationType, string $channel): bool
    {
        // Check user preferences or other logic
        return true;
    }

    public function getNotificationPreferences(): array
    {
        return []; // Return notification preferences
    }
}
```

## Custom Notification Channels

Glueful's notification system can be extended with custom notification channels to deliver notifications through additional services like SMS, push notifications, Slack, or any other delivery method.

### Creating a Custom Notification Channel

A notification channel must implement the `NotificationChannel` interface, which defines the contract for all notification channels in the system.

#### Step 1: Create Your Channel Class

```php
<?php
declare(strict_types=1);

namespace YourNamespace;

use Glueful\Notifications\Contracts\Notifiable;
use Glueful\Notifications\Contracts\NotificationChannel;

class SlackNotificationChannel implements NotificationChannel
{
    /**
     * @var array Configuration options for the Slack channel
     */
    private array $config;

    /**
     * SlackNotificationChannel constructor
     *
     * @param array $config Configuration options
     */
    public function __construct(array $config = [])
    {
        $this->config = $config;
    }

    /**
     * Get the channel name.
     *
     * @return string The name of the notification channel
     */
    public function getChannelName(): string
    {
        return 'slack';
    }

    /**
     * Send the notification to the specified notifiable entity.
     *
     * @param Notifiable $notifiable The entity receiving the notification
     * @param array $data Notification data including content and metadata
     * @return bool Whether the notification was sent successfully
     */
    public function send(Notifiable $notifiable, array $data): bool
    {
        // Get the Slack webhook URL
        $webhookUrl = $notifiable->routeNotificationFor('slack') ?? $this->config['webhook_url'] ?? null;

        if (!$webhookUrl) {
            return false;
        }

        // Format the data for Slack
        $payload = $this->formatPayload($data);

        // Send to Slack using webhook
        return $this->sendToWebhook($webhookUrl, $payload);
    }

    /**
     * Format the notification data for this channel.
     *
     * @param array $data The raw notification data
     * @param Notifiable $notifiable The entity receiving the notification
     * @return array The formatted data for this channel
     */
    public function format(array $data, Notifiable $notifiable): array
    {
        // Format the notification data for Slack
        return [
            'text' => $data['subject'] ?? 'New notification',
            'blocks' => [
                [
                    'type' => 'section',
                    'text' => [
                        'type' => 'mrkdwn',
                        'text' => $data['message'] ?? $data['subject'] ?? 'No content'
                    ]
                ]
            ],
            'attachments' => $this->formatAttachments($data)
        ];
    }

    /**
     * Check if the channel is available.
     *
     * @return bool Whether the channel is available for use
     */
    public function isAvailable(): bool
    {
        // Check if the Slack integration is properly configured
        return isset($this->config['webhook_url']) || isset($this->config['api_token']);
    }

    // Private helper methods...
}
```

#### Step 2: Register Your Channel

Once you've created your channel class, you need to register it with the `ChannelManager`. The simplest way to do this is through an extension:

```php
<?php
declare(strict_types=1);

namespace YourNamespace;

use Glueful\Notifications\Contracts\NotificationExtension;
use Glueful\Notifications\Contracts\Notifiable;

class SlackNotificationExtension implements NotificationExtension
{
    /**
     * @var SlackNotificationChannel The Slack channel instance
     */
    private SlackNotificationChannel $channel;

    /**
     * @var array Configuration options
     */
    private array $config = [];

    /**
     * Get the extension name.
     *
     * @return string The name of the notification extension
     */
    public function getExtensionName(): string
    {
        return 'slack_notification';
    }

    /**
     * Initialize the extension.
     *
     * @param array $config Configuration options for the extension
     * @return bool Whether the initialization was successful
     */
    public function initialize(array $config = []): bool
    {
        $this->config = $config;
        $this->channel = new SlackNotificationChannel($config);
        return true;
    }

    /**
     * Get the notification channel provided by this extension.
     *
     * @return SlackNotificationChannel The Slack notification channel
     */
    public function getChannel(): SlackNotificationChannel
    {
        return $this->channel;
    }

    // Other required methods...
}
```

#### Step 3: Register Your Extension

Create a provider class to register your extension with the system:

```php
<?php
declare(strict_types=1);

namespace YourNamespace;

use Glueful\Helpers\ExtensionManager;

class SlackNotificationProvider
{
    public function register(ExtensionManager $extensionManager)
    {
        // Create the extension
        $extension = new SlackNotificationExtension();

        // Initialize it with configuration
        $extension->initialize([
            'webhook_url' => env('SLACK_WEBHOOK_URL'),
            'api_token' => env('SLACK_API_TOKEN'),
            'default_channel' => env('SLACK_DEFAULT_CHANNEL', '#notifications')
        ]);

        // Register the extension with the notification dispatcher
        $notificationDispatcher = $extensionManager->getNotificationDispatcher();
        $notificationDispatcher->registerExtension($extension);

        // Register the channel with the channel manager
        $channelManager = $notificationDispatcher->getChannelManager();
        $channelManager->registerChannel($extension->getChannel());
    }
}
```

#### Step 4: Configure Your Extension

Add your extension configuration to `config/extensions.php`:

```php
return [
    // Other extensions...
    'slack_notification' => [
        'provider' => \YourNamespace\SlackNotificationProvider::class,
        'enabled' => true,
        'config' => [
            'webhook_url' => env('SLACK_WEBHOOK_URL'),
            'api_token' => env('SLACK_API_TOKEN'),
            'default_channel' => env('SLACK_DEFAULT_CHANNEL', '#notifications'),
        ],
    ],
];
```

### Supporting Notification Routing

To make your channel work seamlessly with the routing system, ensure that notifiable entities can provide appropriate routing information:

```php
class User implements \Glueful\Notifications\Contracts\Notifiable
{
    // ... other Notifiable methods ...

    public function routeNotificationFor(string $channel)
    {
        if ($channel === 'slack') {
            return $this->slack_webhook_url ?? $this->slack_user_id ?? null;
        }

        // Handle other channels
        return parent::routeNotificationFor($channel);
    }
}
```

### Best Practices for Custom Channels

1. **Error Handling**: Always implement robust error handling in your channel's `send()` method.
2. **Configuration**: Make your channel configurable through environment variables.
3. **Throttling**: Implement rate limiting to avoid API rate limits with external services.
4. **Fallbacks**: Consider providing fallback mechanisms when primary delivery fails.
5. **Logging**: Log sending attempts and results for debugging purposes.
