---
title: Seeding
description: Populating your database with test and initial data in Glueful
navigation:
  icon: i-lucide-database
---

# Database Seeding

Database seeding is the process of populating your database with initial or test data. Glueful provides powerful tools for seeding your database in a structured, repeatable way.

## Getting Started with Database Seeding

Database seeding in Glueful is typically handled through migrations, allowing you to version control your seed data alongside your schema changes.

## Creating a Seeder Migration

Seeders are implemented as standard migrations but focus on inserting data rather than modifying the schema:

```php
<?php

use Glueful\Database\Migrations\MigrationInterface;
use Glueful\Database\Schema\SchemaManager;
use Glueful\Database\Connection;
use Glueful\Database\QueryBuilder;
use Glueful\Helpers\Utils;

class SeedProductData implements MigrationInterface
{
    /** @var QueryBuilder Database interaction instance */
    private QueryBuilder $db;

    /**
     * Execute the seeding process
     *
     * @param SchemaManager $schema Database schema manager
     */
    public function up(SchemaManager $schema): void
    {
        $connection = new Connection();
        $this->db = new QueryBuilder($connection->getPDO(), $connection->getDriver());

        // Seed products
        $products = [
            [
                'uuid' => Utils::generateNanoID(),
                'name' => 'Premium Widget',
                'price' => 29.99,
                'description' => 'Our best-selling widget with premium features',
                'status' => 'active'
            ],
            [
                'uuid' => Utils::generateNanoID(),
                'name' => 'Standard Gadget',
                'price' => 19.99,
                'description' => 'Reliable gadget for everyday use',
                'status' => 'active'
            ],
            [
                'uuid' => Utils::generateNanoID(),
                'name' => 'Economy Tool',
                'price' => 9.99,
                'description' => 'Affordable tool for basic needs',
                'status' => 'active'
            ]
        ];

        foreach ($products as $product) {
            $this->db->insert('products', $product);
        }

        // Seed categories
        $categories = [
            [
                'uuid' => Utils::generateNanoID(),
                'name' => 'Electronics',
                'slug' => 'electronics'
            ],
            [
                'uuid' => Utils::generateNanoID(),
                'name' => 'Home & Garden',
                'slug' => 'home-garden'
            ],
            [
                'uuid' => Utils::generateNanoID(),
                'name' => 'Office Supplies',
                'slug' => 'office-supplies'
            ]
        ];

        foreach ($categories as $category) {
            $this->db->insert('categories', $category);
        }
    }

    /**
     * Reverse the seeding process
     *
     * @param SchemaManager $schema Database schema manager
     */
    public function down(SchemaManager $schema): void
    {
        // Remove seeded data
        $this->db->delete('products', ['name' => ['Premium Widget', 'Standard Gadget', 'Economy Tool']]);
        $this->db->delete('categories', ['slug' => ['electronics', 'home-garden', 'office-supplies']]);
    }

    /**
     * Get migration description
     *
     * @return string Migration description
     */
    public function getDescription(): string
    {
        return 'Seed product and category data';
    }
}
```

## Running Seeds

Since seeders are implemented as migrations, they're run using the standard migration commands:

```bash
php glueful migrate
```

To run a specific seeder:

```bash
php glueful migrate:file 005_SeedProductData.php
```

## Best Practices for Seeding

### 1. Use Transactions

Wrap your seed operations in transactions to ensure data integrity:

```php
public function up(SchemaManager $schema): void
{
    $connection = new Connection();
    $this->db = new QueryBuilder($connection->getPDO(), $connection->getDriver());

    try {
        $this->db->beginTransaction();

        // Your seed operations here
        $this->db->insert('users', ['name' => 'John Doe', 'email' => 'john@example.com']);
        $this->db->insert('profiles', ['user_id' => $this->db->lastInsertId(), 'bio' => 'User bio']);

        $this->db->commit();
    } catch (\Exception $e) {
        $this->db->rollback();
        throw $e;
    }
}
```

### 2. Include Data Dependencies

When seeding related data, handle the relationships properly:

```php
// First create parent records
$categoryId = $this->db->insert('categories', [
    'uuid' => Utils::generateNanoID(),
    'name' => 'Electronics'
]);

// Then create child records with references
$this->db->insert('products', [
    'uuid' => Utils::generateNanoID(),
    'name' => 'Smart Device',
    'category_id' => $categoryId,
    'price' => 99.99
]);
```

### 3. Use Unique Identifiers

Always use unique identifiers to avoid duplicate data:

```php
// Check if record already exists first
$existingUser = $this->db->select('users', ['id'], ['email' => 'admin@example.com']);

if (empty($existingUser)) {
    $this->db->insert('users', [
        'uuid' => Utils::generateNanoID(),
        'email' => 'admin@example.com',
        'role' => 'admin'
    ]);
}
```

### 4. Keep Test Data Separate

Use environment detection to add additional test data in development:

```php
public function up(SchemaManager $schema): void
{
    $connection = new Connection();
    $this->db = new QueryBuilder($connection->getPDO(), $connection->getDriver());

    // Always seed essential data
    $this->seedEssentialData();

    // Only seed test data in development environment
    if (getenv('APP_ENV') === 'development') {
        $this->seedTestData();
    }
}

private function seedEssentialData(): void
{
    // Seed minimal data required for production
}

private function seedTestData(): void
{
    // Seed extensive data for testing
}
```

## Creating Factory Methods

For generating large amounts of test data, factory methods are helpful:

```php
/**
 * Create a product with random data
 *
 * @param array $overrides Values to override defaults
 * @return array Product data
 */
private function createProduct(array $overrides = []): array
{
    $product = [
        'uuid' => Utils::generateNanoID(),
        'name' => 'Product ' . rand(100, 999),
        'price' => rand(5, 100) + 0.99,
        'description' => 'This is a sample product description.',
        'status' => 'active',
        'created_at' => date('Y-m-d H:i:s')
    ];

    return array_merge($product, $overrides);
}

/**
 * Generate multiple products
 *
 * @param int $count Number of products to generate
 * @return array Array of product data
 */
private function generateProducts(int $count): array
{
    $products = [];

    for ($i = 0; $i < $count; $i++) {
        $products[] = $this->createProduct();
    }

    return $products;
}
```

## Advanced Seeding Techniques

### Seeding with Relationships

When seeding complex relationships, build them in the correct order:

```php
public function up(SchemaManager $schema): void
{
    // Setup
    $connection = new Connection();
    $this->db = new QueryBuilder($connection->getPDO(), $connection->getDriver());

    // 1. Create users
    $userIds = $this->seedUsers(5);

    // 2. Create categories
    $categoryIds = $this->seedCategories(3);

    // 3. Create products with category relationships
    $productIds = $this->seedProducts(20, $categoryIds);

    // 4. Create orders with user relationships
    $orderIds = $this->seedOrders(10, $userIds);

    // 5. Create order items linking orders and products
    $this->seedOrderItems($orderIds, $productIds);
}
```

### Using External Data Sources

You can seed data from external sources like CSV files or APIs:

```php
private function seedFromCsv(string $filepath, string $table): void
{
    if (!file_exists($filepath)) {
        throw new \RuntimeException("CSV file not found: $filepath");
    }

    $file = fopen($filepath, 'r');

    // Get headers from first row
    $headers = fgetcsv($file);

    // Process data rows
    while (($row = fgetcsv($file)) !== false) {
        $data = array_combine($headers, $row);
        $this->db->insert($table, $data);
    }

    fclose($file);
}
```

## Handling Environment-Specific Data

Different environments often need different seed data:

```php
public function up(SchemaManager $schema): void
{
    $env = getenv('APP_ENV') ?: 'production';
    $seedMethod = 'seed' . ucfirst($env);

    // Call environment-specific seed method if it exists
    if (method_exists($this, $seedMethod)) {
        $this->$seedMethod();
    } else {
        $this->seedProduction();
    }
}

private function seedProduction(): void
{
    // Minimal required data for production
}

private function seedDevelopment(): void
{
    // Extensive data for development
    $this->seedProduction();
    // Add more development-specific data
}

private function seedTesting(): void
{
    // Specific test data
    // Could be completely different from production data
}
```

## Conclusion

Properly implemented database seeding is essential for application development, testing, and initial deployment. By following these practices, you can ensure your Glueful application has consistent, reliable data across all environments.
